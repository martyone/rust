From 1a88dab9c4551739632829b7737bf8db900278ab Mon Sep 17 00:00:00 2001
From: bjorn3 <bjorn3@users.noreply.github.com>
Date: Mon, 9 Nov 2020 17:21:18 +0100
Subject: [PATCH 07/10] Always send message through FinishOnDrop

---
 src/cargo/core/compiler/job_queue.rs | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/tools/cargo/src/cargo/core/compiler/job_queue.rs b/src/tools/cargo/src/cargo/core/compiler/job_queue.rs
index b5c544619..ee19103b9 100644
--- a/src/tools/cargo/src/cargo/core/compiler/job_queue.rs
+++ b/src/tools/cargo/src/cargo/core/compiler/job_queue.rs
@@ -806,10 +806,9 @@ impl<'a, 'cfg> DrainState<'a, 'cfg> {
             let mut sender = FinishOnDrop {
                 messages: &messages,
                 id,
-                ok: false,
+                result: None,
             };
-            let result = job.run(&state);
-            sender.ok = true;
+            sender.result = Some(job.run(&state));
 
             // If the `rmeta_required` wasn't consumed but it was set
             // previously, then we either have:
@@ -823,12 +822,10 @@ impl<'a, 'cfg> DrainState<'a, 'cfg> {
             // we'll just naturally abort the compilation operation but for 1
             // we need to make sure that the metadata is flagged as produced so
             // send a synthetic message here.
-            if state.rmeta_required.get() && result.is_ok() {
+            if state.rmeta_required.get() && sender.result.as_ref().unwrap().is_ok() {
                 messages.push(Message::Finish(id, Artifact::Metadata, Ok(())));
             }
 
-            messages.push(Message::Finish(id, Artifact::All, result));
-
             // Use a helper struct with a `Drop` implementation to guarantee
             // that a `Finish` message is sent even if our job panics. We
             // shouldn't panic unless there's a bug in Cargo, so we just need
@@ -836,12 +833,15 @@ impl<'a, 'cfg> DrainState<'a, 'cfg> {
             struct FinishOnDrop<'a> {
                 messages: &'a Queue<Message>,
                 id: JobId,
-                ok: bool,
+                result: Option<CargoResult<()>>,
             }
 
             impl Drop for FinishOnDrop<'_> {
                 fn drop(&mut self) {
-                    if !self.ok {
+                    if let Some(result) = self.result.take() {
+                        self.messages
+                            .push(Message::Finish(self.id, Artifact::All, result));
+                    } else {
                         self.messages.push(Message::Finish(
                             self.id,
                             Artifact::All,
-- 
2.29.2

